## Аспектно ориентированное программирование (АОП)

Было время, когда разработка программ велась исключительно в процедурном стиле, что конечно же имело свои преимущества, 
например, скорость написания кода и возможность обратиться к любой процедуре из любой точки программы неограниченное количество раз.

> Процедурное программирование - это парадигма программирования основанная на концепции разделения кода на подпрограммы или процедуры, 
содержащие ряд вычислительных шагов, которые необходимо выполнить.

Но такой подход оказалось абсолютно неэффективным с ростом проектов и необходимостью их долгосрочной поддержки и расширения.
Тогда на помощь пришло ООП с его модульностью и понятными человеку абстракциями,
что не только решило вышеперечисленные недостатки ПП, но стало толчком в развитии отрасли в целом. 
Чем проще работать с кодом, чем меньше у программистов уходит времени на обучение и разработку, тем больше денег зарабатывает бизнес. 
Именно поэтому главным критерием качества вашего кода считается его читабельность и ясность.
Какое-то время спустя, для выполнения всё тех же задач, Робертом Мартином были сформулированы 5 принципов проектирования 
ясной и расширяемой архитектуры приложений, первые буквы которых, так ловко сложились в английское слово **solid**.
Согласно первому его принципу, каждый юнит **(method, class, package, module)** вашего кода должен отвечать за выполнение 
только одной задачи на одном уровне абстракции.
Казалось бы, всё ясно, но как быть с тем кодом, который необходимо выполнять параллельно основному. Например, 
как посчитать время работы метода не нарушив при этом SRP ни в самом методе, ни в классе, в котором он вызывается? 
На этот вопрос нам и ответит **АОП**.

> **АОП** - парадигма программирования основная на идее разделения основного и служебного функционала.
К служебному функционалу относится код не касающийся непосредственно бизнес задачи.

##### Пример бизнес задачи:
- Чтение данных из файла;

##### Примеры служебной задачи:
- Проверка доступа пользователя к файлу;
- Логирование служебной информации;
- Обработка исключений;

Для решения задачи в аспектно ориентировании стиле, нам необходимо вынести сквозную логику за пределы метода. 
В этом уроке мы рассмотрим несколько примеров того, как это можно сделать с использованием **Spring Framework** и расширением **AspectJ**.

## Логирование с применением АОП.

Чтобы начать использовать магию аспектно ориентированного программирования в связке со спринг бутом, первое, что нам необходимо сделать это добавить 2 зависимости в `pom.xml` файл. </br>
**spring-aspects** - для подключения модуля спринга, а так же библиотеку **aspectj**, так как спринг под капотом использует его методы.

        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-aspects</artifactId>
            <version>RELEASE</version>
        </dependency>
        <dependency>
            <groupId>org.aspectj</groupId>
            <artifactId>aspectjrt</artifactId>
            <version>1.9.9.1</version>
        </dependency>

После подключения зависимостей нам становятся доступны все необходимые аннотации и можно переходить к написанию первого **аспект класса**.

> Aspect class - класс содержащий сквозную логику, объединённую по её контексту и области взаимодействия с проектом. 

Создадим новый пакет и класс с соответствующим его контексту именем. Для того чтобы класс стал аспектным поставим аннотацию `@Aspect` и `@Component`.

И следующее понятие с которым нам необходимо познакомиться это **Advice**.

> **Advice** - метод находящийся внутри аспект класса, который содержит сквозную логику, 
такую как: логирование, профилирование, контроль доступа, обработка транзакций, обработка исключений, кеширование и т. д.

Advices делятся на несколько видов, каждый из которых будет отрабатывать на определённой фазе выполнения метода:
- **Before** (`@Before`)
- **After** / **After finally** (`@After`)
- **Around** (`@Around`)
- **After returning** (`@AfterReturning`)
- **After throwing** (`@AfterThrowing`)

Для примера, создадим метод который логирует вызов метода `findAll` на объекте типа `CategoryService`.

    @Log4j2 
    @Aspect
    @Component
    public class LoggingAspect {
        @Before("execution(* mate.academy.springboot.aop.service.CategoryService.findAll())")
        public void findAllCategoryAdvice() {
            log.info("Method findAll was called.");
        }
    }

Как мы видим, для того чтобы сконфигурировать наш **advice** таким образом, чтобы он исполнялся
перед вызовом метода `сategoryService.findAll`, мы использовали аннотацию `@Before` в которую
передали паттерн описывающий сигнатуру метода. Такие выражения называют **pointcut**
Для указания конкретного юнита нам нужно прописать полный путь до его местонахождения.

Для написания **pointcut** в спринге используется **AspectJ Pointcut expression language**.
Они имеют следующую структуру:
    
    execution(modifiers-pattern? ret-type-pattern declaring-type-pattern?name-pattern(param-pattern) throws-pattern?)

- **modifiers-pattern** - (опциональный) Видимость метода (public, protected, private, *) 
- **ret-type-pattern** - Возвращаемы тип метода
- **declaring-type-pattern** - (опциональный) Пакет или класс (например: com.app.service.* — применяется ко всем классам в этом пакете, com.app.service.UserService — применяется только к классу UserService, * — все)
- **name-pattern** - имя метода (пример: set* - все сеттеры)
- **param-pattern** - параметры метода (.. - любое количество параметров, java.lang.String - метод, принимающий String в качестве параметра.)
- **throws-pattern** - (опциональный) метод, выбрасывающий это исключение.

> **Join points** - это моменты выполнения программы в которые
необходимо внедрить дополнительный код. Например: вызов метода или обращение к полю класса.

Чтобы получить доступ к сигнатуре метода, аргументам и другой информации о `join points`,
можно воспользоваться объектом `JoinPoint`, который будет передан в параметры **advice**.

    @Before("execution(public * mate.academy.springboot.aop.service.ProductService.save("
            + "mate.academy.springboot.aop.model.Product))")
    public void saveProductAdvice(JoinPoint joinPoint) {
      Product product = (Product) joinPoint.getArgs()[0];
      log.info("Method ProductService.save was called. Args: {"
                + "Id = " + product.getId()
                + "; Name = " + product.getName()
                + "; Price = " + product.getPrice()
                + ";");
    }

В этом примере для нашего **advice** били установлены следующие конфигурации:
- Он должен быть отработан перед методом с именем `save`, который находится в интерфейсе `ProductService`;
- Модификатор доступа - `public`;
- Метод может возвращать любой тип данных;
- И принимать в качестве аргумента только один объект типа `Product`. 
Так же, благодаря объекту `JoinPoint`, мы прокачали наше логирование и теперь, кроме сообщения, мы так же выводим информацию о сохраняемом продукте.

> **Pointcuts** можно прописывать отдельно от **advice** и переиспользовать сколько угодно раз. Сделать это можно с помощью аннотации 
`@Pointcut`, которая ставится над методом и принимает **pointcut expression** в качестве аргумента. Пример синтаксиса можно найти в следующем примере.
> Так же их можно комбинировать с помощью && || и !.

## Профилирование с применением AOP

Рассмотрим ещё один пример, в котором мы измерим скорость выполнения каждого метода класса `TimeWasteService` с использованием объекта
`ProceedingJoinPoint` а так же стандартным классом спринга `StopWatch`.

    @Log4j2
    @Aspect
    @Component
    public class ProfilingAspect {
        @Pointcut("within(mate.academy.springboot.aop.service.TimeWasteService)")
        public void allMethodsFromTimeWasteService() {
        }

        @Around("allMethodsFromTimeWasteService()")
        public Object profileTimeWasteService(ProceedingJoinPoint proceedingJoinPoint) throws Throwable {
            StopWatch stopWatch = new StopWatch();
            stopWatch.start();
            Object result = proceedingJoinPoint.proceed();
            stopWatch.stop();
            log.info(stopWatch.prettyPrint());
            return result;
        }
    }

Тут нам пригодился указатель `within`, который определяет в пределах какого типа будет отрабатывать данный **advice**.

Помимо основного `execution` и `within`, AspectJ поддерживает и другие указатели для более частных случаев, такие как:
- `this` и `target` - выполнение точки соединения, соответствующей объекту указанного типа;
- `args` - выполнение точки соединения, в которой доступен аргумент указанного типа;
- `call` - вызов метода или набора методов подходящих по условию;
- `initialization` - инициализация класса;

Итого мы узнали, как написать простейший аспект класс и познакомились с основными понятиями данного подхода, такими как:
**Aspect**, **Join point**, **Advice**, **Pointcut**.

### Преимущества
Благодаря отделению основной логики метода, цель которой описана в его имени,
от второстепенных служебных задач мы одновременно добиваемся
- Соблюдение принципа единой ответственности
- Соблюдение принципа Don't repeat yourself.
- Лёгкость чтения и понимания основной логики проекта.
- Упрощение unit тестирования.

### Недостатки
К минусам АОП можно отнести 2 вещи:
- Небольшое проседания производительности из-за проксирования бинов.
  Так же стоит сказать, что если все делать грамотно и не перегружать код бесчисленными аспектами,
  то в большинстве случаев преимущества такого подхода гораздо весомее.
- Высокий порог вхождения. Трудности понимания концепция, из-за её неочевидности. 
А так же риск написать ещё более запутанный код, злоупотребляя использованием аспектов.

###  AOP в спринге
Spring по умолчанию поддерживает АОП и использует данный подход под капотом, например, в spring security.
С помощью спринга можно решить базовые, самые популярные задачи в этом направлении, в то время как AspectJ
предоставляет более широкий функционал решающий практически все возможные задачи.
Для работы АОП в чистом спринге в config классе нужно добавить аннотацию `@EnableAspectJAutoProxy`. 
В spring boot такой необходимости нет.

Полезные ссылки:

- [Pointcut examples](https://howtodoinjava.com/spring-aop/aspectj-pointcut-expressions/)

- [Spring AOP proxy under hood.](https://www.google.com/amp/s/habr.com/ru/amp/post/597797/)

- [Spring guide. AOP in Spring Framework.](https://proselyte.net/tutorials/spring-tutorial-full-version/aop-with-spring/)
